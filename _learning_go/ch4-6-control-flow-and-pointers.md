---
layout: post
title: Chapter 4-6 Control Flow and Pointers
date: 2024/9/19
chapter: 4
toc: true
---

## 第四章 块与控制结构

### 块 block

- 常见的块：package block（函数之外的部分）、file block（引入的模块）、function block；
- 内部块的声明会隐藏（shadow）外部块，而不会导致重定义错误。**这对 if 等语句同样适用**：
    - `:=` 赋值符号不要求左侧变量均未定义，但**只会复用当前块中的同名变量**。

```go
func main() {
    x := 10
    if x > 5 {
        fmt.Println(x)  // 10
        x := 5
        fmt.Println(x)  // 5
    }
    fmt.Println(x)  // 10
}
```

- 可使用 `shadow` 工具检测隐藏变量；
- 事实上内置类型并非关键字，而是**定义在 universe block 中的预声明标识符，可以被覆盖**。

### 条件 if

- 语法类似 C，不需要在条件表达式周围添加括号；
- **在条件表达式声明的变量仅限于 if-else 语句块**：

```go
if n := rand.Intn(10); n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}
fmt.Println(n) // undefined
```

### 循环 for

- **唯一的循环关键字**；
- 语法：
    - （C 风格）`for i := 0; i < 10; i++ {}`
    - （while 类型）`for i < 100 {}`
    - （无限循环）`for {}`
    - （迭代）`for i, v := range vals {}`，支持数组、切片（使用索引值）、字符串（**使用字符 rune 而非字节 byte 迭代**，得到的值是整数类型）、映射（使用键）等。可以使用下划线 `_` 替代无用变量，不需要值时可以直接省略 `, v`。
- Go 不推荐 if 语句嵌套，而应使用 `break` 和 `continue` 简化代码；
- 使用 `for-range` 处理映射时，**多次迭代的顺序会不尽相同**；
- `for-range` 得到的循环变量为原值的复制，无法基于此修改原始值；
- **在 `for` 语句前（同一块内）添加标签，从而可以给 `break` 和 `continue` 指定跳出的位置**。

### 跳转 switch

- 每个 case/default 自动**构成一个单独的 block**，其中的变量仅块中可见；
- **Go 中的 `switch` 没有 fall-through，不需要添加 `break`**，但 `break` 依然可用于提前结束分支。如需要利用 fall-through，则可在 case 条件表达式中使用逗号隔开：`case 1,2,3: `；
- 任何可比较的类型均可使用 `switch` 跳转；
- 与 for 类似，**`switch` 支持无变量的跳转**（blank switch），本质上**相当于用 `true` 跳转**；
- `switch` 常用于数值的不同类似情况讨论。

### 直接跳转 goto

- 用法同 C 语言，使用标签跳转。

## 第五章 函数

### 定义

- Go 是强类型语言，需要在定义函数时指明类型：
    - 带返回值与参数的函数定义方式：`func div(num, den int) int {}` （可省略同类）；
    - 无返回值与参数的函数定义方式：`func main() {}`。
- Go 的函数**不支持关键字参数与可选参数**。可以通过传入结构的方式来模拟这两个功能；
- Go 支持**可变参数**（variadic parameters）：
    - 在参数列表中**使用 `...` 来表示可变参数**：`vals ...int`；
    - 可变参数的变量会被定义为**该类型的切片**；
    - 前文中提到，`vals...` 还可用于切片的拆包，以单个参数的形式传入。
- Go 支持多个返回值：
    - **定义函数时用括号、逗号表示：`(int, int, error)`**，返回时无需括号；
    - 在调用此类函数时，可以使用 `:=` 赋值符号来保存不同类型的多个返回值，**不可仅赋值给一个变量**（与 Python 不同）；
    - 通常可以将 `error` 类设为最后一个返回值，表示错误；
    - 返回值也可以设置名称：`(result int, remainder int)`。这事实上是**在函数开始前提前声明这些变量**，可以直接在函数内使用，在函数外不可见。**最终也可以不返回这些变量**；
    - 设置返回值名称后，可以用空返回语句，直接返回返回值变量的当前值。但不建议使用。

### 函数的本质

- Go 中的**函数也是值**，其类型由**参数和返回值的类型**（不是名称）指定，这构成了函数的签名（signature）。因此函数也可以由映射存储：

```go
var opMap = map[string]func(int, int) int{
    "+": add,
    "-": sub,
    "*": mul,
    "/": div
}
```

- `type` 关键字用来定义高级类型：`type name ...`，可以用以定义结构与函数签名类型；
- 与结构类似，也可以定义匿名函数：`func(j int) {}`，还可以直接调用（后加括号）；
- **使用 `type` 定义的函数签名类型不可以直接用于创建函数**，可以创建一个该类型变量，再将同参数的匿名函数赋值给它，以此实现间接定义。

### 闭包

- 与 Python 类似，闭包是函数内定义的函数；
- 闭包内部函数的作用域仅限于定义的函数，但如果它**通过函数调用的参数或返回值传递到了其他作用域**，那么就可以实现一些特殊的应用：
    - `sort.Slice(s, f)` 函数中的 `f` 通常以匿名函数（闭包）实现，它接受索引值 `i,j` 为参数，**需要在函数中访问函数外定义的切片 `s`**；
    - 可以通过返回闭包的方式，实现函数构造器。

### 延迟调用 defer

```go
func main() {
    if len(os.Args) < 2 {                // os.Args
        log.Fatal("no file specified")   // log.Fatal
    }
    f, err := os.Open(os.Args[1])        // os.Open
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()                      // f.Close (delayed)
    data := make([]byte, 2048)
    for {
        count, err := f.Read(data)       // f.Read
        os.Stdout.Write(data[:count])
        if err != nil {
            if err != io.EOF {
                log.Fatal(err)
            }
            break
        }
    }
}
```

- `defer` 可以**推迟函数的调用时机**，直到该函数的末尾（**`return` 之后**）。**适合用于资源释放**；
- 可以推迟调用多个函数，最后添加的函数最先调用；
- 当 `defer` 函数调用包含参数时，**参数的值会在实际调用（函数结束后）再计算**；
- 使用有名称的返回值时，可以根据返回值设置不同的处理流程（可用匿名闭包定义）；
- 如果在一个函数中分配了某种资源，那么通常会在返回值中一同包含释放资源的闭包，在主流程中就可以延迟调用这一函数。

### 按值调用 Call By Value

- 不仅仅是原始类型，**所有的函数参数均按值传递**（同 C/C++）；
- **映射和切片的实现与指针相关（见后文），因此直接将它们函数参数时，可以修改其中的部分内容**（可以增删键值对、修改切片元素，但不能增长切片）；
- **Go 中的所有类型表示的均是值，只是有的类型表示的是指针值**。

## 第六章 指针

### 指针简介

- **指针类型的定义方式为 `*type`**，指针零值为 nil（由此可看出，切片、映射和函数由指针实现），**它不等于 0**（与 NULL 不同，定义在 universe block 中）；
- Go 中的指针**不允许进行算术运算**，仅支持 `*`（indirection） 和 `&` （address）操作；
- `new(type)` 函数可以创建指定类型变量，并返回地址。不过通常用 `&` 替代（结构可以直接使用名称创建 `x := &Foo{}`，但字面量不可以）；
- **Go 中的内存管理机制不同于 C（自动检测引用数）**，因此可以用下面的方法获取字面量指针：

```go
func stringp(s string) *string {
    return &s  // s will not be freed
}
```

### 指针的含义与特性

- 在 Python, Java 等语言中，**类的实例都以指针的形式实现，传递参数时会复制指针值**，因此可以在函数中修改实例属性。在 C 语言中，指针需要**显式指定**，可以使用指针引用原始类型与结构体等复合类型。Go 是两者的结合：可以通过显式传递指针的方式处理原始类型与结构，也可以通过隐式传递指针（切片、映射）等方式处理复合类型；
- Go 中**通过选择传递指针还是值的方式，指定该参数是否不可变**；
- **尽量减少指针的使用**，只在必要时传递指针参数。

### 再谈映射与切片

- **映射使用指针传递（底层实现为指向某个结构的指针）**，只能作为可变类型，无法保证数据安全。应当使用结构代替；
- **切片使用结构（复制值）传递**，该结构中存储了长度（`length`）、容量（`capacity`）和内存地址（`array`）数据域。如果将它作为参数传递到函数中，那么**依然会访问同一片内存地址空间（`array` 指针值相同），但无法修改长度、容量等（只会在复制品中修改，不影响原切片）**；
- 由于切片行为的不一致性，一般假设函数中不会改变切片的内容，如需修改需要在文档中说明。

### 垃圾回收

- 为了减少资源分配与回收的次数，可以**将切片用作读写缓冲区**，避免在每次读取时分配新空间；
- 在 Go 中，要将指针指向的数据保存在栈中，需要满足以下要求，否则就会被存储在堆中（**无需像 C/C++ 一样手动选择数据定义的方式**）：
    - 数据大小在编译时已知的局部变量；
    - 函数结束时不会返回该指针（数据地址函数外不可见）；
    - 如果指针被传入另一函数，则另一函数也需保证这些条件成立。
- 垃圾回收算法并非完美，且数据在 RAM 中的位置也会影响读取速率（顺序读取速度更快，这在 Java、Python 等语言中并未实现），有必要控制垃圾规模。


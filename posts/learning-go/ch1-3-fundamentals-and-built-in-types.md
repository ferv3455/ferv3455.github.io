---
layout: post
title: Learning Go Chapter 1-3 Fundamentals and Built-in Types
date: 2024/9/19
---

# Learning Go 笔记 1：语言及内置类型

## 第一章 环境配置

### Go 安装与运行

- Go 是编译性语言；
- 执行 `go run` 命令时，会将二进制文件放置在临时目录中，并在运行后删除；
- 执行 `go build` 命令会执行编译指令（类似于 gcc 和 clang）；
- 使用 `go install` 安装第三方包；
- 使用 `go fmt` 排版代码， `goimports` 包提供了更全面的功能；
- Go 会**在编译时添加行末的分号**，当且仅当行末为标识符、常量、操作符与**末尾括号**。因此需要注意大括号的换行，对代码风格提出了强制要求；
- `golint` 和 `go vet` 提供了代码风格与正确性的检查。

### Makefile

- `.DEFAULT_GOAL := xxx` 设定 `make` 所执行的 target；
- `target: ` 用来定义 target，分号后包含前置 target 条件；
- `.PHONY: xxx` 用来排除同名文件，常用于定义 target。

## 第二章 原始类型与声明

### 内置类型

- **所有声明变量都会被赋予 0 值**；
- 对于较长的数值变量，**可以使用下划线 `_` 进行数位划分**： `1_234`；
- 常量不含类型，会在被赋值给变量时再检查类型；
- 整数：
    - 类型：八种带/不带符号整数 `int8`-`uint64`、`byte`、`int`、`uint`、`rune`、`uintptr`；
    - 操作符：加减乘除模及赋值、大小关系比较、位操作（**&^表示与非**）。
- 浮点数：`float32` 与 `float64`；
- 复数：`complex64` 与 `complex128`（浮点数扩展），使用 `complex()` 或 `i` 定义，使用 `real()`、`imag()` 获取实部虚部。
- 与 C/C++ 一致，使用单引号表示字符，双引号表示字符串；
- 字符串：
    - 可以**使用撇号 \` 来表示原始字符串**，其中的字符都会被视作原始字符，而非转义符；
    - 字符串可以用大小关系符号进行字典序排序，使用加号连接；
    - 字符串**不可变**。
- **字符使用 `rune` 类型表示**，等价于 `int32`。

### 声明与赋值

- 声明变量类型：`var a bool`；
- 初始化变量：`var x int = 10`。如果类型一致，可省略类型；
- 可以同时初始化两个不同类型变量：`var x, y = 10, "hello"`；
- 可以使用声明列表：

```go
var (
    x    int
    y        = 20
    z    int = 30
    d, e     = 40, "hello"
    f, g string
)
```

- 不同大类之间**不支持变量类型的隐式转换**，必须要使用对应的类型名转换，**布尔类型也如此**；
- **在函数内**可使用 `:=` 替换 `var`：`x, y := 10, "hello"`，且**这些变量不需要都不存在**；
- 所有声明的变量必须被访问，否则会抛出编译错误；
- Go 推荐使用**驼峰命名法**。

### 常量

- 用 `const` 替代 `var`，可定义常量；
- 常量可以被定义为无类型常量，使用时等同于字面常量：`const x = 10`；
- 常量的名称同样遵循驼峰命名法，无需大写（大写字符变量有特定用途）。

## 第三章 复合类型

### 数组 array

- 定义：
    - `var x [3]int`；
    - `var x = [12]int{1,5:4,6,10:100,15}`；
    - `var x = [...]int{10,20,30}`；
    - `var x [2][3]int`。
- 可以使用等于号**比较数组元素是否相等**（可比较，比较值）；
- `len(x)` 返回数组长度；
- **数组的长度是类型的一部分，且不同长度数组无法进行类型转换**。

### 切片 slice

- 定义：
    - `var x = []int{10,20,30}`；
    - `var x = []int{1,5:4,6, 10:100,15}`；
    - `var x [][]int`。
    - `var x []int`：**初始化为 `nil`（无类型）**；
    - `var x = []int{}`：初始化为空切片（长度为 0，非 nil）
- **切片不可直接比较，只可判断是否为 nil**；
- `len(x)` 返回切片长度，`nil` 为 0；
- `append(x, val, ...)` **复制切片**，将所有元素添加到切片末尾，返回新的切片。**可以使用 `y...` 将一个切片拆包**，把元素逐个添加到另一切片末尾。**返回值未被赋值时会抛出编译错误**；
- `cap(x)` 返回切片的容量（或数组的固定长度），**容量会在不足时翻倍**（过大时除外）；
- 使用 `make` 来避免不必要的扩容操作：
    - `x := make([]int, 5)` 会**初始化前 5 个元素为 0**；
    - `x := make([]int, 0,10)` 会设置容量为 10，长度为 0。
- 切片的切片：
    - 一般切片 `x[:2]` 类似 Python，但不支持负数索引值；
    - **切片的切片并不会复制数据，而是共享内存**；
    - 子切片的容量为原切片的容量减去偏移量，因此在子切片上的增删改操作会影响原切片；
    - **全切片指明了共享内存的范围：第三个数值指明了父切片中共享内存的末端**，如果对子切片的操作超过了共享内存的容量，那么就会**创建新的切片，而不影响父切片**。
- 数组也可以切片，同样会共享内存；
- `copy(y, x)` 将 `x` 中尽可能多的元素复制到 `y`（两者较短的），返回复制的元素个数。也可利用切片共享内存的特点，复制同一切片中的部分，或是数组中的部分；

### 字符串 string、字符 rune 与字节 byte

- 字符串 string 使用字节序列表示，通常假设由字符串的 UTF-8 编码表示：
    - 可以索引其中的字符 byte；
    - 可以切片得到字符串 string；
    - **如果某个 Unicode 字符的 UTF-8 编码表示需要占用多个字符，则会影响字符串的长度**。
- 字符串与字符、字节、切片之间可以相互转换：使用 `string(), []byte(), []rune()` 转换：

```go
var s string = "Hello, ☀"
var bs []byte = []byte(s)  // [72 101 108 108 111 44 32 240 159 140 158]
var rs []rune = []rune(s)  // [72 101 108 108 111 44 32 127774]
```

- **应当使用 `strings` 与 `unicode/utf-8` 包中的函数处理字符串**。

### 映射 map

- 定义：
    - `var nilMap map[string]int`： 初始化为 nil。**查元素返回零值，写元素会导致异常**；
    - `totalWins := map[string]int{}`：初始化为空映射。也可自定义内容：

```go
teams := map[string][]string {
    "Orcas": []string{"Fred", "Ralph", "Bijou"},
    "Lions": []string{"Sarah", "Peter", "Billie"},
    "Kittens": []string{"Waldo", "Raul", "Ze"},
}
```

- 键必须是可比较的类型（不能为切片与映射）；
- **映射不可直接比较，只可判断是否为 nil**；
- 与切片一样，支持 `len()`，且会自动扩容；
- 使用 `make` 来创建大小为 0，但容量为指定大小的映射：`make(map[int][]string, 10)`；
- 读取不存在的键值对时，**返回对应类型的零值**。**可以运算赋值给不存在的键值对**（类似于 defaultdict）；
- Comma ok idiom：可使用 `v, ok := m["hello"]` 判断是否存在该元素；
- `delete(m, key)` 删除映射的键值对，无返回值，**不会在 nil 或不存在键值对时抛出异常**；
- 可以使用映射替代集合的功能。

### 结构 struct

- **Go 语言没有类与继承，但它仍然具有 OOP 的一些特点**；
- 定义：

```go
type person struct {
    name string
    age int
    pet string
}

var fred person
bob := person{}   // same as the previous line (zero fields)

julia := person{"Julia", 40, "cat"}
beth := person{age: 30, name: "Beth"}
```

- 匿名结构：

```go
var person struct {
    name string
    age int
    pet string
}

pet := struct {
    name string
    kind string
}{
    name: "Fido",
    kind: "dog",
}
```

- 结构中的域可以添加**标签（struct tags）**：

```go
type person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}
```

- **如果结构的所有域均是可比较的，那么该结构可比较**；
- 当且仅当两个结构的定义拥有完全相同的域名、类型和顺序时，它们的实例之间可以类型转换；
- 不同类型的结构之间不可以比较，但**可以比较相同定义的有名与匿名结构**。

